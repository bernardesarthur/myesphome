Sempre que atualizar o HomeAssistant, seguir a ordem:

- Fazer backup e salvar no computador
- Atualizar o Home Assistant OS (ha os update)
- Atualizar o Home Assistant Supervisor (ha supervisor update)
- Atualizar o Home Assistant Core (ha core update)
- Atualizar os AddOns

- platform: history_stats
    name: Tempo Luz da Cozinha
    entity_id: switch.sonoff_1000ea34bd
    state: 'on'
    type: time
    start: '{{ now().replace(hour=0).replace(minute=0).replace(second=0) }}'
    end: '{{ now() }}'

#template cover

backyard_door_main:
      friendly_name: "Portão Quintal"
      value_template: "{{ is_state('binary_sensor.portao_qtl', 'on') }}"
      turn_on:
        service: switch.toggle
        data:
          entity_id: switch.fechadura_qtl
      turn_off:
        service: switch.toggle
        data:
          entity_id: switch.fechadura_qtl
      icon_template: >-
        {% if is_state('binary_sensor.portao_qtl', 'on') %}
          mdi:door-open
        {% else %}
          mdi:door
        {% endif %}

switch:
  - platform: template
    switches:
      seguranca_casa:
        value_template: '{{ states("input_boolean.seguranca_casa") }}'
        friendly_name: 'Segurança da Casa'
        turn_on:
          - service: input_boolean.turn_on
            entity_id: input_boolean.seguranca_casa
          - service: alarm_control_panel.alarm_arm_away
            data:
              entity_id: alarm_control_panel.alarme_da_casa
              code: !secret senha_alarme
        turn_off:
          - service: input_boolean.turn_off
            entity_id: input_boolean.seguranca_casa
          - service: alarm_control_panel.alarm_disarm
            data:
              entity_id: alarm_control_panel.alarme_da_casa
              code: !secret senha_alarme

o WOL é só pra ligar, mas no switch vc define um comando no apertar ( off ) para desligar, segue ex:

- platform: wake_on_lan
  name: WOL_GamerPC
  mac: 24:4B:FE:B7:EA:69
  host: 10.0.0.245
  turn_off:
    service: button.press
    target:
      entity_id: button.gamerpc_command_shutdown

camera:
  - platform: ffmpeg
    name: Frente
    input: -rtsp_transport tcp -i rtsp://USUARIO:SENHA@IP_DVR:554/cam/realmonitor?channel=1&subtype=1

  - platform: ffmpeg
    name: Lateral
    input: -rtsp_transport tcp -i rtsp://USUARIO:SENHA@IP_DVR:554/cam/realmonitor?channel=2&subtype=1

template:

  - sensor:
    - name: "Energia Consumida - kWh"
      unique_id: energia_consumida_kwh
      unit_of_measurement: "kWh"
      device_class: "energy"
      state_class: "total_increasing"
      state: "{{ states('sensor.energia_consumida') | float }}"
      icon: "mdi:something"

    - name: "Energia Injetada - kWh"
      unique_id: energia_injetada_kwh
      unit_of_measurement: "kWh"
      device_class: "energy"
      state_class: "total_increasing"
      state: "{{ states('sensor.energia_injetada') | float }}"
      icon: "mdi:something"

    - name: "Energia Total - kWh"
      unique_id: energia_total_kwh
      unit_of_measurement: "kWh"
      device_class: "energy"
      state_class: "total_increasing"
      state: "{{ states('sensor.energia_total') | float }}"
      icon: "mdi:something"

    - name: "Energia - Soma Total kWh"
      unique_id: energia_soma_total
      state: "{{ (states('sensor.fase1_energia') | float  + states('sensor.fase2_energia') | float ) | float  }}"
      unit_of_measurement: kWh
      state_class: total_increasing
      device_class: energy
      icon: "mdi:something"

customize:
  sensor.med_energia_energia_total:
    device_class: energy
    state_class: total_increasing
    unit_of_measurement: kWh

sensor:
  - platform: integration
    source: sensor.pzem_003_power
    name: pzem_003_energy
    unit_prefix: k
    unit_time: h
    round: 3
    method: left

switch:
  - platform: broadlink
    host: 192.168.87.7
    mac: '78:0F:77:18:39:F8'
    type: rm_mini
    timeout: 300
    switches:
      xboom_som:
        friendly_name: "Sonzeira"
        command_on: 'JgBeAJOUEhMSExMSExIROBITERQRFBETEhMRFBEUETgSExEUERQRExI4EjcSOBI4ERMSExITETkRExITEhMRFBE4EjgSNxIABpWUlRI4EgAMVZKVEjgSAAxVk5UROBIADQUAAAAAAAAAAAAA'
        command_off: 'JgBeAJOUEhMSExMSExIROBITERQRFBETEhMRFBEUETgSExEUERQRExI4EjcSOBI4ERMSExITETkRExITEhMRFBE4EjgSNxIABpWUlRI4EgAMVZKVEjgSAAxVk5UROBIADQUAAAAAAAAAAAAA'
      tv_lg_55:
        friendly_name: "Tv da Sala"
        command_on: 'JgBQAAABKZQQFRETEjgRFBEUERQRFBEUETgROREUETkRORA6EDkROREUERQRFBE5EBURExITEhMSOBE5EDoQFRE4ETkRORE5EAAFLAABKUoRAA0FAAAAAAAAAAA='
        command_off: 'JgBQAAABKZQQFRETEjgRFBEUERQRFBEUETgROREUETkRORA6EDkROREUERQRFBE5EBURExITEhMSOBE5EDoQFRE4ETkRORE5EAAFLAABKUoRAA0FAAAAAAAAAAA='
      projetor:
        friendly_name: Projetor
        command_on: 'JgBgAAABI5MSExA5ERMRFBETERQQFRETETcTEhI4ETgQORI4ETgQORE4ERMRORE4EDkRFBAUEhISExA5EhMQFRETETgSNxE4EgAFEwABJkkTAAw6AAElRhUADDgAASVIEwANBQAAAAAAAAAA'
        command_off: 'JgBgAAABI5MSExA5ERMRFBETERQQFRETETcTEhI4ETgQORI4ETgQORE4ERMRORE4EDkRFBAUEhISExA5EhMQFRETETgSNxE4EgAFEwABJkkTAAw6AAElRhUADDgAASVIEwANBQAAAAAAAAAA'
      htv:
        friendly_name: "Android TV"
        command_on: 'JgBYAAABJ5ITExITEhMTExITEhMTExI4EjgSOBI4EjgSOBM3EjgTOBITEjgSExM3ExMRFBITExMSOBITEjgSFBI4EjgSOBI4EQAE/gABJksSAAxgAAEmTBEADQU='
        command_off: 'JgBYAAABJ5ITExITEhMTExITEhMTExI4EjgSOBI4EjgSOBM3EjgTOBITEjgSExM3ExMRFBITExMSOBITEjgSFBI4EjgSOBI4EQAE/gABJksSAAxgAAEmTBEADQU='

# Comandos Tasmota (https://tasmota.github.io/docs/Commands/)

SetOption21 1 (monitorar energia mesmo desligado)
TelePeriod [10.3600 seconds]
PowerOnState (0 = OFF, 1 = ON, 3 = LAST STATE)
Sleep 0 (desliga energy saving)
SetOption55 1 (ligar mDNS)
SaveData (salvar dados a cada 1 segundo)
PowerDelta X (até 100% de mudança de energia)
EnergyTotal 0 / EnergyToday 0 / EnergyYesterday 0 (resetar energia)
Time 0 (enable NTP)
Timezone -3
PowerSet 60.0 (calibrar potência em 60W)
VoltageSet 127 (calibrar tensão em 127V)
CurrentSet 1000 (calibrar corrente em 1A, valor definido em mA)
SetOption114 1 (desconectar switch do relay e enviar mensagens do switch via MQTT, 0 é o valor padrão, onde conecta o switch no relay e para de enviar mensagens via MQTT)
SetOption73 1 (desconectar botão do relay e enviar mensagens do botão via MQTT, 0 é o valor padrão, onde conecta o botão no relay e para de enviar mensagens via MQTT)
SetOption19 0 (Ativar integração com Home Assistant)
SetOption30 0 (exibir entidade como switch)
SetOption30 1 (exibir entidade como light)
SetOption65 1 (desativar reset por Power Cycle)
Interlock 0 (disable)
Interlock 1 (enable)
Interlock 1,2 3,4 (dois grupos com relay 1 e 2 no grupo 1 e relay 3 e 4 no grupo 2)
PulseTime<X> 0 (disable) (X é o número do relay)
PulseTime<X> 1 … 111 (incremento de 0.1s, exemplo, 5 igual a 0.5s (500ms) (X é o número do relay)
PulseTime<X> 112 … 64900 exemplo: 113 igual a 13 segundos (adicione 100 ao intervalo desejado em segundos, exemplo: 460 = 6 minutos = 360 segundos) (X é o número do relay)
SwitchMode<X> 0 (default toggle) <X> é o número do switch, se for 0 aplica para todos
SwitchMode<X> 5 (pulsador com hold) <X> é o número do switch, se for 0 aplica para todos
SwitchMode<X> 7 (pulsador sem hold) <X> é o número do switch, se for 0 aplica para todos
InfoRetain 1
PowerRetain 1
ButtonRetain 1
SensorRetain 1
StateRetain 1
StatusRetain 1
SwitchRetain 1
SetOption59 1 - Enviar mensagem de atualização de status no tópico TELE

Desligar as mensagens de RETAIN antes de apagar o dispositivo do Home Assistant.

Usar Shelly Plus 2M para cortina.

# Interruptor Ventilador # 

switch:
  - platform: template
    switches:
      ventilador_do_quarto_do_meio:
        unique_id: ventilador_do_quarto_do_meio
        friendly_name: "Ventilador do Quarto do Meio"
        value_template: >-
          {{ states('sensor.luz_do_quarto_do_meio_power')|float > 50.0 }} 
        turn_on:
          service: remote.send_command
          data:
            command: PowerVentilador
            device: Ventilador Suite
            entity_id: remote.broadlink_rm4_pro_remote
        turn_off:
          service: remote.send_command
          data:
            command: PowerVentilador
            device: Ventilador Suite
            entity_id: remote.broadlink_rm4_pro_remote

template:
    sensor:
      - name: "Nível de Água"
        unique_id: nivel_de_agua
        unit_of_measurement: "%"
        icon: mdi:water
        state: >
          {% set distancia1 = states('sensor.monitor_caixa_dagua_sr04_distance') | float %}
          {% set distanciareal = (distancia1 - 30.5) | float %}
          {% set alturamax = 50 | float %}
          {% set nivelcalculado = ((1 - (distanciareal / alturamax)) * 100 |float) | round(0) %}
          {{ nivelcalculado }}

#Para monitorar (ligado/desligado)

binary_sensor:
  - platform: ping
    unique_id: teste
    host: <IP do dispositivo>
    name: "nome do dispositivo"
    count: 2
    scan_interval: 30
    
#Rastreamento

device_tracker:
  - platform: ping
    hosts:
      nome_do_dispositivo_1: <IP do dispositivo>

sensor:
  - platform: snmp
    name: 'ether1_wan_in'
    host: 192.168.212.1
    baseoid: 1.3.6.1.2.1.31.1.1.1.6.1
    community: 'public'
    version: '2c'
    scan_interval: 180

service: notify.alexa_media_echo_dot_de_sala_de_estar
data:
  data:
    type: tts
  message: >-
    A temperatura externa é {{ state_attr('weather.forecast_casa_no_setsul',
    'temperature') | float(0) }} graus.

{{ state_attr('weather.forecast_casa_no_setsul', 'temperature') | float }}
{{ states('sensor.sensor_de_th_do_nosso_quarto_temperature') | float }}

Para inverter o status de um sensor de porta e janela no Home Assistant usando um template, você pode usar a função binary_sensor e o atributo device_class do sensor. Aqui está um exemplo de como fazer isso:

binary_sensor:
  - platform: template
    sensors:
      inverted_door_sensor:
        friendly_name: "Porta Invertida"
        device_class: door
        unique_id: inverted_door_sensor
        value_template: "{{ is_state('binary_sensor.original_door_sensor', 'off') }}"

binary_sensor:
  - platform: template
    sensors:
      inverted_door_sensor:
        device_class: door
        unique_id: inverted_door_sensor
        friendly_name: "Inverted Door Sensor"
        value_template: "{{ not is_state('binary_sensor.original_door_sensor', 'on') }}"

Neste exemplo, o sensor inverted_door_sensor inverte o status do sensor original chamado original_door_sensor. Se o sensor original estiver desligado (off), o novo sensor estará ligado (on), e vice-versa.
Lembre-se de substituir 'binary_sensor.original_door_sensor' pelo ID real do sensor de porta e janela que você deseja inverter. Certifique-se também de ajustar a classe do dispositivo (device_class) de acordo com o tipo de sensor (no exemplo, usei 'door' para um sensor de porta).

Reset energy
To reset Sum of consumed energy, use the Dev console and execute:
Endpoint: 1
Cluster: 0x00
Command: 0
Payload: (don't change this)

Next time the plug gets polled, Sum of consumed energy will start from zero again.

  - platform: template
  switches:
    ventilador_do_quarto_do_meio:
      friendly_name: "Ventilador do Quarto do Meio"
      unique_id: ventilador_do_quarto_do_meio
      value_template: >-
        {{ states('sensor.luz_do_quarto_do_meio_power')|float > 50.0 }}
      turn_on:
        service: remote.send_command
        data:
          command: PowerVentilador
          device: Ventilador Suite
          entity_id: remote.broadlink_rm4_pro_remote
      turn_off:
        service: remote.send_command
        data:
          command: PowerVentilador
          device: Ventilador Suite
          entity_id: remote.broadlink_rm4_pro_remote

Explicação sobre os nós:

- Throttle - Limitar mensagens 
- Delay - Atrasar mensagens
- Trigger - Aguardar mensagens
- Join - Juntar mensagens
- Template - Criar mensagens
- Change - Modificar mensagens
- Switch - Direcionar mensagens
- Random - Gerar mensagens aleatórias
- Time Range, Time Check and Within Time - Verificar horários
- WeekDay - Verificar dias da semana
- Timer - Disparar mensagem em determinado horário ou dia da semana
- Home Assistant - Nós do sistema, o campo data insere comandos personalizados

Automação com Home Assistant:

- Iluminação
- Áudio
- Vídeo
- Cortinas
- Câmeras
- Internet
- Cinema
- Piscina
- Portão de garagem
- Contato seco
- Interruptores de luz
- Controladores de fita LED
- Lâmpadas
- Controladores infravermelho
- Sensores de presença e contato
- Sensores de temperatura e umidade
- Relés
- Zigbee
- Tasmota
- EspHome
- Shelly
- MagicHome (RGW 0x06, RGB 0x33, DIM 0x41 e Pixel v3 0xA3)
- WLED
- BroadLink
- Yeelight
- HomeKit Device

Começar instalando Home Assistant, configurar a interface do Home Assistant. Em seguida:

- Instalar MQTT
- Instalar Zigbee2Mqtt
- Instalar nodeRED
- Instalar terminal SSH
- Ajustar recorder
- Instalar editor de arquivos
- Instalar EspHome
- Instalar HACS
- Instalar integrações personalizadas
- Instalar dispositivos 
- Configurar Lovelace
- Configurar automações e cenas no nodeRED

Os dispositivos Tuya que não mostrarem todas as opções no Zigbee2Mqtt, como Power_On_Behavior, Calibration_Time e Backlight_Mode, configurar primeiro no Gateway Zigbee Tuya, colocar em modo de pareamento e depois colocar no Zigbee2Mqtt.

zigbee2mqtt/ID-DEVICE/set -m '{"power_on_behavior": off}'

{
    "media_content_id": "COMANDO",
    "media_content_type": "custom"
}

Nodes utilizados no nodeRED:

- node-red-contrib-zigbee2mqtt
- node-red-contrib-weekday
- node-red-contrib-sun-position
- node-red-contrib-throttle
- node-red-node-suncalc
- thingzi-logic-timers

#### Alexa TTS com mensagem ####

{
   "message":"Seja bem-vindo ao lar, estou aqui para te ajudar!",
   "data":{"type":"tts"}
}

#### Alexa TTS com payload #####

{
   "message":"{{payload}}",
   "data":{"type":"tts"}
}

type: custom:mini-graph-card
entities:
  - sensor.tasmota_energy_voltage
icon: mdi:sine-wave
show:
  labels: false
  extrema: true
color_thresholds:
  - value: 210
    color: '#19D745'
  - value: 220
    color: '#0E01FF'
  - value: 230
    color: '#FF1400'

template.yaml

- sensor:

  - name: "Temperatura externa"
    unique_id: "temperatura_externa"
    unit_of_measurement: "°C"
    device_class: "temperature"
    state_class: "measurement"
    state: "{{ state_attr('weather.forecast_casa_no_setsul', 'temperature') | float }}"
    icon: "mdi:thermometer"
    
  - name: "Umidade externa"
    unique_id: "umidade_externa"
    unit_of_measurement: "%"
    device_class: "humidity"
    state_class: "measurement"
    state: "{{ state_attr('weather.forecast_casa_no_setsul', 'humidity') | float }}"
    icon: "mdi:water-percent"

sensor:
      
  - platform: template
    sensors:
      memory_use_percent:
        friendly_name: Uso de Memória
        unit_of_measurement: "%"
        value_template: "{{(states('sensor.memory_use')|float - 0) * (100 - 0) / (2048 - 0) + 0}}"

# Se precisar especificar state_class e device_class, usar:

  template.yaml ou fazer via template - sensor nos ajudantes da interface gráfica

- sensor:

  - name: "Temperatura externa"
    unique_id: "temperatura_externa"
    unit_of_measurement: "°C"
    device_class: "temperature"
    state_class: "measurement"
    state: "{{ state_attr('weather.forecast_casa_no_setsul', 'temperature') | float }}"
    icon: "mdi:thermometer"

# Se não for especificar state_class e device_class, usar:

sensor.yaml:
      
- platform: template
  sensors:
    energia_gasta_dia_pressurizador_komeco:
      unique_id: energia_gasta_dia_pressurizador_komeco
      friendly_name: "pressurizador_komeco gastou hoje"
      icon_template: mdi:cash-usd-outline
      unit_of_measurement: "R$"
      value_template: "{{ ( float(states.sensor.tomada_pressurizador_energy_today.state) * float(states.input_text.text_valor_kwh.state) ) | round(2) }}"
    energia_gasta_ontem_pressurizador_komeco:
      unique_id: energia_gasta_ontem_pressurizador_komeco
      friendly_name: "pressurizador_komeco gastou ontem"
      icon_template: mdi:cash-usd-outline
      unit_of_measurement: "R$"
      value_template: "{{ ( float(states.sensor.tomada_pressurizador_energy_yesterday.state) * float(states.input_text.text_valor_kwh.state) ) | round(2) }}"
    energia_gasta_semana_pressurizador_komeco:
      unique_id: energia_gasta_semana_pressurizador_komeco
      friendly_name: "pressurizador_komeco Gastou na semana"
      icon_template: mdi:cash-usd-outline
      unit_of_measurement: "R$"
      value_template: "{{ ( float(states.sensor.consumo_energia_semana_pressurizador_komeco.state) * float(states.input_text.text_valor_kwh.state) ) | round(2) }}"
    energia_gasta_mes_pressurizador_komeco:
      unique_id: energia_gasta_mes_pressurizador_komeco
      friendly_name: "pressurizador_komeco Gastou no mês"
      icon_template: mdi:cash-usd-outline
      unit_of_measurement: "R$"
      value_template: "{{ ( float(states.sensor.consumo_energia_mes_pressurizador_komeco.state) * float(states.input_text.text_valor_kwh.state) ) | round(2) }}"

    pressurizador_komeco_status:
      unique_id: pressurizador_komeco_status
      friendly_name_template: Status pressurizador_komeco
      value_template: >-
        {% if is_state('switch.tomada_pressurizador', 'off') %}
          Desligada
        {% elif states('sensor.tomada_pressurizador_energy_power')|float > 4 %}
          Ligada
        {% else %}
          Standby
        {% endif %}
      icon_template: >-
        {% if is_state('switch.tomada_pressurizador', 'off') %}
          mdi:power-off
        {% elif states('sensor.tomada_pressurizador_energy_power')|float > 4 %}
          mdi:power
        {% else %}
          mdi:power-cycle
        {% endif %}

# Broadlink NodeRED

  # send_command

{
    "device": "32756745",
    "command": [
        "turn on",
        "turn off display"
    ],
    "num_repeats": 20,
    "delay_secs": 1,
    "hold_secs": 2
}

  # learn_command

{
    "device": "32756745",
    "command": [
        "turn on",
        "turn off",
        "volume up",
        "volume down"
    ],
    "num_repeats": 20,
    "delay_secs": 1,
    "hold_secs": 2,
    "alternative": "true",
    "command_type": "rf"
}

  # delete_command

{
    "device": "television",
    "command": "Mute"
}

Call service:

    domain: mqtt
    service: publish
    data: below

#PARA ATIVAR O MODO COPIAR DO IR

{
    "topic": "zigbee2mqtt/NOME_DADO_AO_DISPOSITIVO/set",
    "payload": "{ \"learn_ir_code\": \"ON\"}"
}

#PARA DESATIVAR O MODO COPIAR DO IR

{
    "topic": "zigbee2mqtt/NOME_DADO_AO_DISPOSITIVO/set",
    "payload": "{ \"learn_ir_code\": \"OFF\"}"
}

#PARA EXECUTAR O COMANDO

{
    "topic": "zigbee2mqtt/NOME_DADO_AO_DISPOSITIVO/set",
    "payload": "{ \"ir_code_to_send\": \"COMANDO_COPIADO\"}"
}

# Usar nos serviços do HA

topic: zigbee2mqtt/NOME_DADO_AO_DISPOSITIVO/set
payload: {"ir_code_to_send":"COMANDO_COPIADO"}

Usar node weekdays para checar os dias da semana no NodeRED.

command_line:
  - switch:
      name: Foscam Motion
      command_on: 'curl -k "https://ipaddress:443/cgi-bin/CGIProxy.fcgi?cmd=setMotionDetectConfig&isEnable=1&usr=admin&pwd=password"'
      command_off: 'curl -k "https://ipaddress:443/cgi-bin/CGIProxy.fcgi?cmd=setMotionDetectConfig&isEnable=0&usr=admin&pwd=password"'
      command_state: 'curl -k --silent "https://ipaddress:443/cgi-bin/CGIProxy.fcgi?cmd=getMotionDetectConfig&usr=admin&pwd=password" | grep -oP "(?<=isEnable>).*?(?=</isEnable>)"'
      value_template: '{{ value == "1" }}'

Usar grupos no Home Assistant para combinar estados E ou OU no nodeRED.

          {% if states('sensor.seu_sensor_de_temperatura') | float > 20 %}
            Quente
          {% else %}
            Frio
          {% endif %}


          {% if states('sensor.seu_sensor_de_temperatura') | float > 20 %}
            Quente
          {% elif states('sensor.seu_sensor_de_temperatura') | float > 10 %}
            Frio
          {% else %}
            Gelado
          {% endif %}

          {% if states('sensor.sensor_de_th_do_nosso_quarto_temperature') | float > 30 %}
            Quente
          {% elif states('sensor.sensor_de_th_do_nosso_quarto_temperature') | float > 29 %}
            Frio
          {% elif states('sensor.sensor_de_th_do_nosso_quarto_temperature') | float < 25 %}
            Teste
          {% else %}
            Gelado
          {% endif %}

          {{ not is_state('sensor.original_sensor', 'on') }}

- platform: template
  sensors:
    potencia_pressurizador:
      friendly_name: "Potência Atual do pressurizador"
      unit_of_measurement: "W"
      value_template: ->{{ [ states('sensor.pressurizador_power_a'), 
        states('sensor.pressurizador_power_b'),] | map('float') | sum }}

      potencia_motores_piscina:
        friendly_name: "Potência Atual do Motores da Piscina"
        unit_of_measurement: "W"
        value_template: ->
          {{ [ states('sensor.motores_piscina_power_a') |float +  states('sensor.motores_piscina_power_b') |float ] }}

      potencia_aquecedor:
        friendly_name: "Potência Atual aquecedor”
        unit_of_measurement: "W"
        value_template:   {{ [ states('sensor.kdt_power_ab’) |float ] }}

Valores delta
Habilite isto se os valores de origem forem valores delta desde a última leitura em vez de valores absolutos. Quando esta opção estiver habilitada, cada novo valor recebido será adicionado como está ao medidor da concessionária, em vez de adicionar a diferença entre o novo valor e o valor anterior.

Redefinindo periodicamente
Habilite isto se for esperado que o estado do sensor de origem seja redefinido para 0, por exemplo, um plugue inteligente que é redefinido na inicialização. Quando esta opção está desabilitada (por exemplo, se o sensor de origem for um medidor de concessionária doméstica que nunca zera durante a vida útil do dispositivo), a diferença entre o novo valor e o último valor válido é adicionada ao medidor de concessionária, o que evita a perda de uma leitura do medidor após o sensor de origem ficar disponível após estar indisponível.

Preparando os sensores de energia a serem utilizados no gerenciamento de energia:
Os sensores de energia que serão utilizados no gerenciamento de energia deverão possuir as seguintes características:
* Unidade de medida (unit_of_measurement) igual a Wh ou kWh
* Classe do dispositivo (device_class) igual a energy
* Classe de estado (state_class) igual a total_increasing ou Classe de estado (state_class) igual a measurement e propriedade last_reset definida.
Para realizar as personalização de propriedades acima, deve ser utilizado a customização de entidades, para isso deve ser incluído/confirmado o include do arquivo customize.yaml no aquivo configuration.yaml conforme abaixo:
homeassistant:
  customize: !include customize.yaml
Incluir a customização da entidade de energia total no arquivo customize.yaml:
sensor.med_energia_energia_total:
  device_class: energy
  state_class: total_increasing
  unit_of_measurement: kWh
Recarregar as configurações ou reiniciar o Home Assistant.

{{(states('sensor.home_assistant_v2_db_size')|float - 0) * (100 - 0) / (8192 - 0) + 0}}

binary_sensor:
  - platform: gpio
    pin: GPIO4
    device_class: moisture
    name: "Sensor 1"
    filters:
     - delayed_on: 50ms

sensor:
  - platform: template
    temperatura_status:
      unique_id: temperatura_status:
      value_template: >-
         {{ float(states.sensor.sensor_de_th_do_nosso_quarto_temperature.state) | round((0)) }}

         {{ ( float(states.sensor.sensor_de_th_do_nosso_quarto_temperature.state) *   float(states.sensor.sensor_de_th_do_nosso_quarto_temperature.state) ) | round((0)) }}

# Quando desejo comparar o valor, usar is_state ou is_state_attr. Se desejo apenas exibir o valor, usar states ou state_attr.

         {% if is_state('switch.soundbar' , 'on') %}
         Quente
         {% elif states('sensor.sensor_de_th_do_nosso_quarto_temperature') | float > 30 < 35 %}
         Frio
         {% elif states('sensor.sensor_de_th_do_nosso_quarto_temperature') | float < 25 %}
         Teste
         {% else %}
         Gelado
         {% endif %}

         {% if is_state_attr('device_tracker.iphone_13', 'battery_level', 100) %}
         Quente
         {% elif states('sensor.sensor_de_th_do_nosso_quarto_temperature') | float > 30 < 35 %}
         Frio
         {% elif states('sensor.sensor_de_th_do_nosso_quarto_temperature') | float < 25 %}
         Teste
         {% else %}
         Gelado
         {% endif %}

         {{ is_state_attr('switch.pppoe_out1', 'running', true) }}

         {{ is_state_attr('switch.pppoe_out1', 'running', false) }}

         {{ is_state_attr('sensor.home_keypad', 'chime', true) }}

         {{ is_state_attr('device_tracker.iphone_13', 'battery_level', 100) }}

         {{ state_attr('device_tracker.iphone_13', 'battery_level') | float > 90 }}

         {{ state_attr('device_tracker.iphone_13', 'battery_level') | float < 90 }}

         {{ state_attr('device_tracker.iphone_13', 'battery_level') | float > 90 < 101 }}

         {{ states('switch.soundbar') == 'on' }}

         {{ state_attr('device_tracker.iphone_13', 'battery_level') == 100 }}

         {{ is_state('switch.source', 'on') }}

         {{ is_state('sensor.skylight.state', 'on') }}

         {%  if state_attr('device_tracker.iphone_13', 'battery_level') | float >= 100 %}
         Quente
         {% elif states('sensor.sensor_de_th_do_nosso_quarto_temperature') | float > 30 < 35 %}
         Frio
         {% elif states('sensor.sensor_de_th_do_nosso_quarto_temperature') | float < 25 %}
         Teste
         {% else %}
         Gelado
         {% endif %}

        {% if state_attr('device_tracker.iphone_13', 'battery_level') == 100 %}
          Quente
        {% elif is_state('binary_sensor.ar_condicionado_do_nosso_quarto', 'on') %}
          Frio
        {% elif states('sensor.sensor_de_th_do_nosso_quarto_temperature') | float < 25 %}
          Teste
        {% else %}
          Gelado
        {% endif %}

         {{ states('sensor.sensor_de_th_da_sala_de_estar_temperature') | float | round ((2)) }}

         {{ state_attr('weather.forecast_casa_no_setsul', 'temperature') | float | round ((2)) }}

         {{ states('sensor.sensor_de_th_da_sala_de_estar_temperature') | float | round ((2)) + states('sensor.sensor_de_th_do_nosso_quarto_temperature') | float | round ((2)) }}

         {{ (states('sensor.sensor_de_th_da_sala_de_estar_temperature') | float | round (2) + states('sensor.sensor_de_th_do_nosso_quarto_temperature') | float | round (2) ) | float | round (2) }}

         {{ states('sensor.tomada_do_rack_da_sala_potencia_real')|float < 80 > 50 }}

         {{ states('sensor.tomada_do_rack_da_sala_potencia_real')|float > 50.0 }}

          {{ states('sensor.tomada_do_rack_da_sala_potencia_real')|float | round ((2)) }}

         {{ states('sensor.tomada_do_rack_da_sala_potencia_real')|float | round ((2))}}

         {% if is_state_attr('switch.pppoe_out1', 'running', true) %}
           Conectado
         {% elif is_state_attr('switch.pppoe_out1', 'running', false) %}
           Desconectado
         {% endif %}

         {{ is_state_attr('switch.pppoe_out1', 'running', true) }}

         {{ is_state_attr('switch.pppoe_out1', 'running', false) }}

{{ state_attr('weather.forecast_casa_no_setsul', 'temperature') | float }}

{{ state_attr('weather.forecast_casa_no_setsul', 'humidity') | float }}

lock:
  - platform: template
    name: Garage door
    value_template: "{{ is_state('sensor.door', 'on') }}"
    lock:
      service: switch.turn_on
      target:
        entity_id: switch.door
    unlock:
      service: switch.turn_off
      target:
        entity_id: switch.door

cover:
  - platform: template
    covers:
      garage_door:
        device_class: garage
        friendly_name: "Garage Door"
        value_template: "{{ states('sensor.garage_door')|float > 0 }}"
        open_cover:
          service: script.open_garage_door
        close_cover:
          service: script.close_garage_door
        stop_cover:
          service: script.stop_garage_door

switch:
  - platform: template
    switches:
      skylight:
        value_template: "{{ is_state('sensor.skylight', 'on') }}"
        turn_on:
          service: switch.turn_on
          target:
            entity_id: switch.skylight_open
        turn_off:
          service: switch.turn_off
          target:
            entity_id: switch.skylight_close

switch:
  - platform: template
    switches:
      notebook:
        friendly_name: "Notebook"
        unique_id: notebook
        value_template: >-
          {{ states('sensor.athom_v2_energy_power')|float > 1.0 }}  
        turn_on:
          service: switch.turn_on
          target:
            entity_id: switch.athom_v2
        turn_off:
          service: switch.turn_off
          target:
            entity_id: switch.athom_v2

  - platform: template
    switches:
      firetv:
        unique_id: firetv
        friendly_name: "FireTV"
        value_template: "{{ states('sensor.tomada_do_rack_da_sala_potencia_real')|float > 50.0 }}"
        turn_on:
          service: media_player.play_media
          target:
            entity_id: media_player.echo_dot_de_sala_de_estar
          data:
            media_content_id: "Ligar Fire T. V."
            media_content_type: "custom"
        turn_off:
          service: media_player.play_media
          target:
            entity_id: media_player.echo_dot_de_sala_de_estar
          data:
            media_content_id: "Desligar Fire T. V."
            media_content_type: "custom"

Sempre usar unique_id nas entidades criadas via YAML.

https://github.com/zigbee2mqtt/hassio-zigbee2mqtt/
http://github.com/zigbee2mqtt/hassio-zigbee2mqtt/
https://github.com/zigbee2mqtt/hassio-zigbee2mqtt
http://github.com/zigbee2mqtt/hassio-zigbee2mqtt

{% set distancia1 = states('sensor.monitor_caixa_dagua_sr04_distance') | float %}
{% if distancia1 > 20 %}
  {% set distanciareal = distancia1 - 30.5 %}
  {% set alturamax = 50 %}
  {% set nivelcalculado = ((1 - (distanciareal / alturamax)) * 100) | round(0) %}
  {% if nivelcalculado > 100 %}
    100
  {% elif nivelcalculado < 0 %}
    0
  {% else %}
    {{ nivelcalculado }}
  {% endif %}
{% else %}
  {{ states('sensor.nivel_de_agua') }}
{% endif %}

         {% if states('sensor.temperatura_externa') | float < 0 %}
         0
         {% elif states('sensor.temperatura_externa') | float > 100 %}
         100
         {% else %}
         {{ states('sensor.temperatura_externa') | float | round ((2)) }}
         {% endif %}

         {% if states('sensor.nivel_caixa_de_agua') | float < 0 %}
         0
         {% elif states('sensor.nivel_caixa_de_agua') | float > 100 %}
         100
         {% else %}
         {{ states('sensor.nivel_caixa_de_agua) | float | round ((2)) }}
         {% endif %}

{{ ( float(states.sensor.sensor_de_th_da_sala_de_estar_temperature.state) - 27 )  | float | round (2) }}

{{ (100 - ( float(states.sensor.sensor_de_th_da_sala_de_estar_temperature.state) * 100 / 60 )) | round(2) }}

{{ (100 - ( float(states.sensor.sensor_de_th_da_sala_de_estar_temperature.state) * 100 / 60 )) | round(2) }} 

{% if (states('sensor.temperatura_externa')|int) > 100 %}
  100
{% else %}
  {{ ((states('sensor.temperatura_externa')|int)|abs) }}
{% endif %}

{% if (states('sensor.temperatura_externa')|float) > 100 %}
  100
{% else %}
  {{ ((states('sensor.temperatura_externa')|float)|float) | round (2) }}
{% endif %}

# Função reset no nodeRED

msg.reset = true;
return msg;

template:
  - sensor:
      - name: Effective Electricity Price
        unique_id: effective_electricity_price
        unit_of_measurement: "€/kWh"
        state: >
            {% set override = float(states('input_number.electricity_price_override')) %}
            {% if override > 0 -%}
              {{ states('input_number.electricity_price_override') }}
            {%- else -%}
              {{ states('sensor.nordpool_ee') }}
            {%- endif %}
  - sensor:
      - name: 'House Energy Cost'
        unique_id: house_energy_cost
        unit_of_measurement: €/h
        state: >-
          {{ states('sensor.house_power')|float / 1000 * states('sensor.effective_electricity_price')|float(0) }}
  - sensor:
      - name: 'Car Charging Cost'
        unique_id: car_charging_cost
        unit_of_measurement: €/h
        state: >-
          {{ states('sensor.car_charger_power')|float / 1000 * states('sensor.effective_electricity_price')|float }}
  - sensor:
      - name: 'Car Charging Cost Hourly'
        unique_id: car_charging_cost_hourly
        unit_of_measurement: €
        state: >-
          {{ states('sensor.car_charger_energy_hourly')|float * states('sensor.effective_electricity_price')|float }}
  - sensor:
      - name: 'Car Charging Cost Daily'
        unique_id: car_charging_cost_daily
        unit_of_measurement: €
        state: >-
          {{ states('sensor.car_charger_energy_daily')|float * states('sensor.effective_electricity_price')|float }}
  - sensor:
      - name: 'Car Charging Cost Monthly'
        unique_id: car_charging_cost_monthly
        unit_of_measurement: €
        state: >-
          {{ states('sensor.car_charger_energy_monthly')|float * states('sensor.effective_electricity_price')|float }}
  - sensor:
      - name: 'Car Charging Cost Yearly'
        unique_id: car_charging_cost_yearly
        unit_of_measurement: €
        state: >-
          {{ states('sensor.car_charger_energy_yearly')|float * states('sensor.effective_electricity_price')|float }}

- name: "Solar Daily Production Interface"
        unique_id: solar_daily_production_interface
        unit_of_measurement: kWh
        icon: mdi:solar-power
        device_class: energy
        state_class: total_increasing
        state: >
          {% if (states('sensor.solar_generation_today_template') != "unavailable") %}
            {{ (states('sensor.solar_generation_today_template')) }}
          {% else %}
            {{ states('sensor.solar_daily_production_interface')|float(default=0) }}
          {% endif %}

value_template: >
  {% set grid_out = states('sensor.solar_power') | float(0) - states('sensor.electricity_used') | float(0) %}
  {% if  grid_out > 0  %}
    {{ grid_out }}
  {% else %}
    0
  {% endif %}

data_template:
  message: "The dryer ran for {{ states('sensor.dryer_on_time') }}"

Fita LED WS2815 de 12V - no máximo 10 metros, ligar o backup no DAT e alimentar direto na fonte, ligando no controlador só o DAT. 
Se for usar mais de uma fonte, emendar os GNDs das fontes e isolar os polos positivos. 
Fita LED comum de 24V - no máximo 10 metros
Em ambas as fitas: alimentar no início e no final da fita. 

        {{now().strftime("%H:%M:%S")}}

No Proxmox sempre configurar VLAN AWARE na interface Bridge antes de criar a primeira VM.

          {% if is_state('device_tracker.iphone_12_de_morgana_bernardes', 'home') or 
                is_state('device_tracker.iphone_13_de_arthur_bernardes', 'home') %}
            ON
          {% elif is_state('device_tracker.iphone_12_de_morgana_bernardes', 'not_home') and
                 is_state('device_tracker.iphone_13_de_arthur_bernardes', 'not_home') %}
            OFF     
          {% else %}
            Unknow
          {% endif %}

           {% if is_state('device_tracker.tasmota_4d6cd0_3280', 'home') or 
                is_state('device_tracker.unifi_default_34_ab_95_a9_98_a9', 'home') or
                is_state('device_tracker.sonoff_mini_do_som_da_cozinha', 'home') or
                is_state('device_tracker.sonoff_pow_r2_do_ar_condicionado_do_nosso_quarto', 'home') or
                is_state('device_tracker.sonoff_s26_1', 'home') or
                is_state('device_tracker.tomada_do_rack_da_sala_de_estar', 'home') %}
            ON
            {% elif is_state('device_tracker.tasmota_4d6cd0_3280', 'not_home') and 
                is_state('device_tracker.unifi_default_34_ab_95_a9_98_a9', 'not_home') and
                is_state('device_tracker.sonoff_mini_do_som_da_cozinha', 'not_home') and
                is_state('device_tracker.sonoff_pow_r2_do_ar_condicionado_do_nosso_quarto', 'not_home') and
                is_state('device_tracker.sonoff_s26_1', 'not_home') and
                is_state('device_tracker.tomada_do_rack_da_sala_de_estar', 'not_home') %}
            OFF     
           {% else %}
            Unknow
           {% endif %}

{% if states('sensor.sonoff_pow_r2_do_ar_condicionado_do_nosso_quarto_potencia_real') | float > 3 %}
  On
{% else %}
  Off
{% endif %}

{% if states('sensor.sonoff_pow_r2_do_ar_condicionado_do_nosso_quarto_potencia_real') | float > 5 %}
  blue
{% elif states('sensor.sonoff_pow_r2_do_ar_condicionado_do_nosso_quarto_potencia_real') | float < 5 %}
  gray
{% else %}
  black
{% endif %}

{{ states('sensor.sensor_de_th_do_nosso_quarto_temperature') | float | round ((2)) }}°C - 
{% if states('sensor.sonoff_pow_r2_do_ar_condicionado_do_nosso_quarto_potencia_real') | float > 3 %}
  Ligado
{% elif states('sensor.sonoff_pow_r2_do_ar_condicionado_do_nosso_quarto_potencia_real') | float < 5 %}
  Desligado
{% else %}
  Offline
{% endif %}

{% if states('sensor.firehd_10_battery_level') | float < 10 %}
  On
{% elif states('sensor.firehd_10_battery_level') | float > 80 %}
  Off
{% else %}
  Unknow
{% endif %}

          {% if is_state('device_tracker.iphone_12_de_morgana_bernardes', 'home') or 
                is_state('device_tracker.iphone_13_de_arthur_bernardes', 'home') %}
            ON
          {% elif is_state('device_tracker.iphone_12_de_morgana_bernardes', 'not_home') and
                 is_state('device_tracker.iphone_13_de_arthur_bernardes', 'not_home') %}
            OFF     
          {% else %}
            Unknow
          {% endif %}

{% set potencia_real = states('sensor.medidor_de_energia_do_quadro_geral_power_x') | float | round ((2)) %}
{% set corrente_total = states('sensor.medidor_de_energia_do_quadro_geral_current_x') | float | round ((2)) %}
{% set tensao = states('sensor.medidor_de_energia_do_quadro_geral_voltage_x') | float | round ((2)) %}
{% set potencia_aparente = (tensao * corrente_total) | float | round ((2)) %}
{% set fator_de_potencia = (potencia_real / potencia_aparente) | float | round ((2)) %}
{{ fator_de_potencia }}

{{ states('sensor.tomada_do_rack_da_sala_potencia_real')|float > 40.0 }}

{% set potencia_real = states('sensor.potencia_geral') | float | round ((2)) %}
{% set corrente_total = states('sensor.corrente_geral') | float | round ((2)) %}
{% set tensao = states('sensor.tensao_media') | float | round ((2)) %}
{% set potencia_aparente = (tensao * corrente_total) | float | round ((2)) %}
{{ potencia_aparente }}

  - platform: template
    covers:
      portao_da_garagem:
        unique_id: portao_da_garagem
        device_class: garage
        friendly_name: "Portão da Garagem"
        value_template: "{{ is_state('binary_sensor.portao_da_garagem', 'on') }}"
        open_cover:
          service: input_button.press
          target:
            entity_id: input_button.comando_da_garagem
        close_cover:
          service: input_button.press
          target:
            entity_id: input_button.comando_da_garagem

  - platform: history_stats
    name: Ar Condicionado do Nosso Quarto - 7 dias - Tempo Ligado
    entity_id: binary_sensor.ar_condicionado_do_nosso_quarto
    state: "on"
    type: time
    end: "{{ now() }}"
    duration:
      days: 7
      
  - platform: history_stats
    name: Ar Condicionado do Nosso Quarto - 7 dias - Contador
    entity_id: binary_sensor.ar_condicionado_do_nosso_quarto
    state: "on"
    type: count
    end: "{{ now() }}"
    duration:
      days: 7
      
  - platform: history_stats
    name: Ar Condicionado do Nosso Quarto - 7 dias - Porcentagem do Tempo Ligado
    entity_id: binary_sensor.ar_condicionado_do_nosso_quarto
    state: "on"
    type: ratio
    end: "{{ now() }}"
    duration:
      days: 7
      
  - platform: history_stats
    name: FireTV Stick - 7 dias - Tempo Ligado
    entity_id: switch.firetv
    state: "on"
    type: time
    end: "{{ now() }}"
    duration:
      days: 7
      
  - platform: history_stats
    name: FireTV Stick - 7 dias - Contador
    entity_id: switch.firetv
    state: "on"
    type: count
    end: "{{ now() }}"
    duration:
      days: 7
      
  - platform: history_stats
    name: FireTV Stick - 7 dias - Porcentagem do Tempo Ligado
    entity_id: switch.firetv
    state: "on"
    type: ratio
    end: "{{ now() }}"
    duration:
      days: 7

https://www.home-assistant.io/integrations/history_stats/

          {% if 
                is_state('update.ssh_web_terminal_update', 'on') or
                is_state('update.file_editor_update', 'on') or
                is_state('update.home_assistant_core_update', 'on') or
                is_state('update.home_assistant_google_drive_backup_update', 'on') or
                is_state('update.home_assistant_operating_system_update', 'on') or
                is_state('update.home_assistant_supervisor_update', 'on') or
                is_state('update.mariadb_update', 'on') or
                is_state('update.matter_server_update', 'on') or
                is_state('update.mosquitto_broker_update', 'on') or
                is_state('update.node_red_update', 'on') or
                is_state('update.samba_share_update', 'on') or
                is_state('update.zigbee2mqtt_update', 'on')
          %}
            ON 
          {% else %}
            OFF
          {% endif %}

{{ state_attr('weather.forecast_casa_no_setsul', 'temperature') | float }}

{{ state_attr('weather.forecast_casa_no_setsul', 'humidity') | float }}

{%-if is_state('binary_sensor.doors_and_windows', 'on') and is_state('group.someone_home','off') %}        
          no occupancy / door open 
 
 {%-elif is_state('binary_sensor.doors_and_windows', 'on') and is_state('group.someone_home','on') %}        
          occupied/door open
 {%-elif is_state('binary_sensor.doors_and_windows', 'off') and is_state('group.someone_home','on') %}        
          occupied/door closed    

 {% endif %}

# Função do nodeRED que confirma se é o último dia do mês

function ultimoDiaDoMesAtual() {
    var data = new Date();
    var ano = data.getFullYear();
    var mes = data.getMonth() + 1; // O método getMonth() retorna o mês no intervalo de 0-11, então adicionamos 1.
    return new Date(ano, mes, 0).getDate(); // Criamos uma nova data com o próximo mês e dia 0, que é o último dia do mês atual.
}

if (new Date().getDate() === ultimoDiaDoMesAtual()) {
    msg.payload = true;
} else {
    msg.payload = false;
}

return msg;

ha core update --version=2024.7.4

{% set temperatura = states('sensor.temperatura_externa') | float %}
{% set umidade = states('sensor.umidade_externa') | float %}
{% if temperatura >= 27 %}
  {% set sensacao = temperatura + (0.33 * umidade) - 4.00 %}
{% elif temperatura < 27 and temperatura >= 20 %}
  {% set sensacao = temperatura %}
{% else %}
  {% set sensacao = temperatura - (0.55 - (0.55 * (umidade / 100))) * (temperatura - 14.5) %}
{% endif %}

{% if sensacao >= 40 %}
  Perigo: Calor extremo
{% elif sensacao >= 35 %}
  Muito quente
{% elif sensacao >= 30 %}
  Quente
{% elif sensacao >= 25 %}
  Agradável
{% elif sensacao >= 18 %}
  Confortável
{% elif sensacao >= 10 %}
  Fresco
{% elif sensacao >= 0 %}
  Frio
{% else %}
  Muito frio
{% endif %}

{% set temperatura = states('sensor.sensor_de_th_do_nosso_quarto_temperature') | float %}
{% set umidade = states('sensor.sensor_de_th_do_nosso_quarto_humidity') | float %}
{% if temperatura >= 27 %}
  {% set sensacao = temperatura + (0.33 * umidade) - 4.00 %}
{% elif temperatura < 27 and temperatura >= 20 %}
  {% set sensacao = temperatura %}
{% else %}
  {% set sensacao = temperatura - (0.55 - (0.55 * (umidade / 100))) * (temperatura - 14.5) %}
{% endif %}

{% if sensacao >= 40 %}
  Perigo: Calor extremo
{% elif sensacao >= 35 %}
  Muito quente
{% elif sensacao >= 30 %}
  Quente
{% elif sensacao >= 25 %}
  Agradável
{% elif sensacao >= 18 %}
  Confortável
{% elif sensacao >= 10 %}
  Fresco
{% elif sensacao >= 0 %}
  Frio
{% else %}
  Muito frio
{% endif %}

{{ 'quente' in states.sensor.conforto_termico_area_externa.state | lower }}

{{ 'quente' in states.sensor.conforto_termico_area_externa.state | lower or 'perigo' in states.sensor.conforto_termico_area_externa.state | lower }}

{{ 'quente' in states.sensor.conforto_termico_area_externa.state | lower and 'perigo' in states.sensor.conforto_termico_area_externa.state | lower }}

// Template que subtrai 4% do valor intermediário
{% set temperatura = states('sensor.sensor_de_th_do_nosso_quarto_temperature') | float %}
{% set umidade = states('sensor.sensor_de_th_do_nosso_quarto_humidity') | float %}
{% if temperatura >= 27 %}
  {% set valor_intermediario = temperatura + (0.33 * umidade) %}
  {% set sensacao = valor_intermediario - (valor_intermediario * 4 / 100) %}
{% elif temperatura < 27 and temperatura >= 20 %}
  {% set sensacao = temperatura %}
{% else %}
  {% set sensacao = temperatura - (0.55 - (0.55 * (umidade / 100))) * (temperatura - 14.5) %}
{% endif %}

/// Checar se está dentro do intervalo definido

{% set time_now = strptime(states('sensor.time'), '%H:%M') %}
{% set hora_despertar = strptime(states('sensor.hora_despertar'), '%H:%M') %}
{% set uma_hora_apos = hora_despertar + timedelta(hours=1) %}

{{ hora_despertar <= time_now <= uma_hora_apos }}

{% set time_now = strptime(states('sensor.time'), '%H:%M') %}
{% set hora_despertar = strptime(states('sensor.hora_despertar'), '%H:%M') %}
{% set trinta_min_apos = hora_despertar + timedelta(minutes=30) %}

{{ hora_despertar <= time_now <= trinta_min_apos }}

{% set time_now = strptime(states('sensor.time'), '%H:%M') %}
{% set hora_despertar = strptime(states('sensor.hora_despertar'), '%H:%M') %}
{% set meia_hora_apos = hora_despertar + timedelta(minutes=30) %}

{{ hora_despertar <= time_now <= meia_hora_apos }}

{% set time_now = strptime(states('sensor.time'), '%H:%M') %}
{% set automacao_bomba = strptime(states('sensor.forecast_solar_peak_hour'), '%H:%M') %}
{% set meia_hora_apos = automacao_bomba + timedelta(minutes=30) %}

{{ automacao_bomba <= time_now <= meia_hora_apos }}

/// Usando input_datetime

{% set time_now = strptime(states('sensor.time'), '%H:%M') %}
{% set hora_despertar = strptime(states('input_datetime.teste_de_hora')[:5], '%H:%M') %}
{% set uma_hora_apos = hora_despertar + timedelta(hours=1) %}

{{ hora_despertar <= time_now <= uma_hora_apos }}

///

/// Gera horário do sol baseado no sensor sun.sun

{% set utc_time_setting = states('sensor.sun_next_setting') %}
{% set sensor_time_setting = utc_time_setting | as_datetime | as_local %}
{{ sensor_time_setting.strftime('%H:%M') }}

{% set utc_time_rising = states('sensor.sun_next_rising') %}
{% set sensor_time_rising = utc_time_rising | as_datetime | as_local %}
{{ sensor_time_rising.strftime('%H:%M') }}

{% set time_now = strptime(states('sensor.time'), '%H:%M') %}
{# Comparação com o horário do próximo pôr do sol #}
{% set sun_next_setting = states('sensor.sun_next_setting') | as_datetime | as_local %}
{% set setting_time = strptime(sun_next_setting.strftime('%H:%M'), '%H:%M') %}
{% set setting_plus_one_hour = setting_time + timedelta(hours=1) %}
{{ setting_time <= time_now <= setting_plus_one_hour }}

{% set time_now = strptime(states('sensor.time'), '%H:%M') %}
{# Comparação com o horário do próximo nascer do sol #}
{% set sun_next_rising = states('sensor.sun_next_rising') | as_datetime | as_local %}
{% set rising_time = strptime(sun_next_rising.strftime('%H:%M'), '%H:%M') %}
{% set rising_plus_one_hour = rising_time + timedelta(hours=1) %}
{{ rising_time <= time_now <= rising_plus_one_hour }}

{% set utc_time_rising = states('sensor.sun_next_rising') %}
{% set sensor_time_rising = utc_time_rising | as_datetime | as_local %}
{# Offset de 1 hora antes #}
{% set one_hour_before = sensor_time_rising - timedelta(hours=1) %}
{# Offset de 1 hora depois #}
{% set one_hour_after = sensor_time_rising + timedelta(hours=1) %}
{{ sensor_time_rising.strftime('%H:%M') }}  {# Horário original #}
{{ one_hour_before.strftime('%H:%M') }}  {# 1 hora antes #}
{{ one_hour_after.strftime('%H:%M') }}  {# 1 hora depois #}

{% set utc_time_rising = states('sensor.sun_next_setting') %}
{% set sensor_time_rising = utc_time_rising | as_datetime | as_local %}
{# Offset de 1 hora antes #}
{% set one_hour_before = sensor_time_rising - timedelta(hours=1) %}
{# Offset de 1 hora depois #}
{% set one_hour_after = sensor_time_rising + timedelta(hours=1) %}
{{ sensor_time_rising.strftime('%H:%M') }}  {# Horário original #}
{{ one_hour_before.strftime('%H:%M') }}  {# 1 hora antes #}
{{ one_hour_after.strftime('%H:%M') }}  {# 1 hora depois #}

///

{% if is_state('device_tracker.iphone_13_de_arthur_bernardes' , 'home') %}
  mdi:home
{% else %}
  mdi:home-remove
{% endif %}

{% if is_state('device_tracker.iphone_13_de_arthur_bernardes' , 'home') %}
  blue
{% else %}
  red
{% endif %}

{% if is_state('device_tracker.iphone_13_de_arthur_bernardes' , 'home') %}
  Casa
{% else %}
  {{ states('sensor.iphone_13_geocoded_location') }}
{% endif %}

{% set conforto = states('sensor.conforto_termico_area_externa') | lower %}
{% if 'quente' in conforto %}
  red
{% elif 'perigo' in conforto %}
  red
{% elif conforto == 'agradável' %}
  blue
{% elif conforto == 'confortável' %}
  blue
{% elif conforto == 'fresco' %}
  blue
{% elif conforto == 'frio' %}
  blue
{% elif conforto == 'muito frio' %}
  blue
{% else %}
  white
{% endif %}

{% set conforto = states('sensor.conforto_termico_area_externa') | lower %}
{% if 'quente' in conforto %}
  red
{% elif 'perigo' in conforto %}
  red
{% elif conforto == 'agradável' %}
  blue
{% elif conforto == 'confortável' %}
  blue
{% elif conforto == 'fresco' %}
  blue
{% elif conforto == 'frio' %}
  blue
{% elif conforto == 'muito frio' %}
  blue
{% else %}
  white
{% endif %}


Lá fora está {% set conforto = states('sensor.conforto_termico_area_externa') | lower %} {{ conforto }}

// Verifica se o valor está entre 21 e 27
if (msg.payload >= 21 && msg.payload <= 27) {
    // Se estiver dentro do intervalo, passa o valor como msg.payload
    return msg;
} else {
    // Se estiver fora do intervalo, configura msg.reset para true
    msg.reset = true;
    delete msg.payload;  // Remove o msg.payload para não causar confusão
    return msg;
}

// Verifica se o valor da carga (payload) da mensagem é diferente de 30
if (msg.payload != 30) {
    // Se for diferente de 30, a função retorna a mensagem original
    return msg;
} else {
    // Se o valor da carga for exatamente 30, a função retorna null (ou seja, não retorna a mensagem)
    return null;
}

// Verifica se o valor da carga (payload) da mensagem é diferente de 30
if (msg.payload != 30) {
    // Se for diferente de 30, a função retorna a mensagem pela saída 1 e null pela saída 2
    return [msg, null];  // Sai pela saída 1 se for diferente de 30
} else {
    // Se o valor da carga for exatamente 30, a função retorna null pela saída 1 e a mensagem pela saída 2
    return [null, msg];  // Sai pela saída 2 se for igual a 30
}

// Verifica se o valor da carga (payload) da mensagem está entre 30 (inclusivo) e 31 (exclusivo)
if (msg.payload >= 30 && msg.payload < 31) {
    // Se o valor estiver nesse intervalo, a função retorna a mensagem pela saída 1 e null pela saída 2
    return [msg, null];  // Sai pela saída 1 se o valor estiver entre 30 e 30.9
} else {
    // Se o valor não estiver no intervalo, a função retorna null pela saída 1 e a mensagem pela saída 2
    return [null, msg];  // Sai pela saída 2 se não estiver nesse intervalo
}

// Verifica se o valor da carga (payload) da mensagem é menor que 30 ou maior ou igual a 31
if (msg.payload < 30 || msg.payload >= 31) {
    // Se o valor for menor que 30 ou maior ou igual a 31, a função retorna null pela saída 1 e a mensagem pela saída 2
    return [null, msg];   // Sai pela saída 2 se o valor for menor que 30 ou maior ou igual a 31
} else {
    // Se o valor estiver entre 30 (inclusivo) e 30.9 (exclusivo), a função retorna a mensagem pela saída 1 e null pela saída 2
    return [msg, null];   // Sai pela saída 1 se o valor estiver entre 30 e 30.9
}

# Para garantir a confiabilidade do sistema de automação com nodeRED, usar as seguintes técnicas:

- Inject após reiniciar o nodeRED e checar o status do dispositivo que deseja: isso impede que uma automação não seja executada corretamente caso o nodeRED seja reiniciado. Pode colocar o inject para executar a cada X tempo para se comportar igual ao Poll State. 
- Poll State: impede que uma automação não seja executada caso o Home Assistant seja reiniciado.
- Output on Connect no node Event State: impede que uma automação não seja executada caso o nodeRED seja reiniciado. * Também é necessário desmarcar todas as caixas de Previous State.
- Atualizar somente no último dia do mês e também fazer backup antes de atualizar. Isso evita interrupções a cada atualização e previne bugs no sistema.

// Pega o atributo forecast da entidade weather.house
let forecast = msg.data.attributes.forecast;

// Verifica se a previsão está disponível
if (forecast && forecast[0]) {
    // Exemplo: Verifica se vai chover no próximo período
    if (forecast[0].condition === 'rainy') {
        msg.payload = "Chuva prevista";
        return [msg, null];  // Saída 1 (condição verdadeira)
    } else {
        msg.payload = "Sem previsão de chuva";
        return [null, msg];  // Saída 2 (condição falsa)
    }
} else {
    return [null, msg];  // Sem dados de previsão
}

{% if is_state('binary_sensor.ar_condicionado', 'on') %}
  ligado
{% else %}
  desligado
{% endif %}

{% if is_state('binary_sensor.ar_condicionado', 'on') %}
  ligado
{% elif is_state('binary_sensor.portao', 'on') %}
  quase ligado
{% else %}
  desligado
{% endif %}

{% if is_state('binary_sensor.ar_condicionado', 'on') and is_state('binary_sensor.portao', 'on') %}
  ligado e quase ligado
{% elif is_state('binary_sensor.ar_condicionado', 'on') %}
  ligado
{% elif is_state('binary_sensor.portao', 'on') %}
  quase ligado
{% else %}
  desligado
{% endif %}

{% set temperatura = states('sensor.temperatura_externa') | int %}
{% set umidade = states('sensor.umidade_externa') | int %}
{% set conforto_termico = states('sensor.conforto_termico_area_externa') %}
{% if 'Perigo' in conforto_termico %}
Lá fora está com Calor Extremo fazendo {{ temperatura }} graus e a umidade está em {{ umidade }}%!
{% else %}
Lá fora está {{ conforto_termico }} com {{ temperatura }} graus e a umidade está em {{ umidade }}%!
{% endif %}

{% set temperatura = states('sensor.temperatura_externa') | int %}
{% set umidade = states('sensor.umidade_externa') | int %}
{% set conforto_termico = states('sensor.conforto_termico') %}
{% if 'Perigo' in conforto_termico %}
  {% set conforto_termico = conforto_termico.replace('Perigo:', '').strip() %}
Lá fora está com {{ conforto_termico }} fazendo {{ temperatura }} graus e a umidade está em {{ umidade }}%!
{% else %}
Lá fora está {{ conforto_termico }} com {{ temperatura }} graus e a umidade está em {{ umidade }}%!
{% endif %}

Usar ESPHOME somente para:

- Switches, Buttons e Relays
- Sensores ultra-sônicos, temperatura, umidade, binários, mmWave e outros. 

Sensores binários (binary_sensor) são: interruptores, botões, sensores de movimento, sensores de contato, boias e etc. 

Os outros sensores ficam na categoria sensor. 

Para monitoramento energético usar apenas Tasmota.

var inputNumber = msg.payload_input_number;
var inputText = msg.payload_input_select;

if (inputNumber > 0) {
    if (inputText && typeof inputText === 'string') {
        // Converter o texto para minúsculas para evitar problemas com maiúsculas/minúsculas
        var lowerInputText = inputText.toLowerCase();

        if (lowerInputText === 'segundos') {
            msg.delay = inputNumber * 1000; // Converter segundos para milissegundos
        } else if (lowerInputText === 'minutos') {
            msg.delay = inputNumber * 60000; // Converter minutos para milissegundos
        } else {
            // Se não for nem "segundos" nem "minutos", não faz nada, mas continua o fluxo
            return msg;
        }
        return msg;
    } else {
        // Se inputText não for válido ou não for uma string
        return msg;
    }
} else {
    // Ignorar se o número for menor ou igual a 0
    return msg;
}

    {% if is_state('binary_sensor.sensor_1', 'on') or
                is_state('binary_sensor.sensor_2', 'on') or
                is_state('binary_sensor.sensor_3', 'on') or
                is_state('binary_sensor.sensor_4', 'on') %}
              on
            {% else %}
                  off
          {% endif %}

// 

// Verifica se o msg.payload_status é diferente de 'HOME' e 'NOT_HOME'.
// Ambas as condições precisam ser verdadeiras para que a mensagem vá para a saída 1.
// Caso contrário, vai para a saída 2.
if (msg.payload_status !== 'HOME' && msg.payload_status !== 'NOT_HOME') {
    return [msg, null];  // Saída 1: Se for diferente de ambos, envia a mensagem.
} else {
    return [null, msg];  // Saída 2: Se for 'HOME' ou 'NOT_HOME', envia a mensagem.
}

// Verifica se o msg.payload_status é igual a 'HOME' ou 'NOT_HOME'.
// Se qualquer uma dessas condições for verdadeira, a mensagem vai para a saída 2.
// Caso contrário, vai para a saída 1.
if (msg.payload_status === 'HOME' || msg.payload_status === 'NOT_HOME') {
    return [null, msg];  // Saída 2: Se for 'HOME' ou 'NOT_HOME', envia a mensagem.
} else {
    return [msg, null];  // Saída 1: Se for diferente de ambos, envia a mensagem.
}

// Verifica se o msg.payload_status é diferente de 'HOME' e 'NOT_HOME'.
// Ambas as condições precisam ser verdadeiras para retornar a mensagem.
// Caso contrário, retorna null.
if (msg.payload_status !== 'HOME' && msg.payload_status !== 'NOT_HOME') {
    return msg;  // Retorna a mensagem se ambas as condições forem verdadeiras.
} else {
    return null;  // Retorna null se qualquer uma das condições for falsa.
}

// Verifica se o msg.payload_status é igual a 'HOME' ou 'NOT_HOME'.
// Se qualquer uma dessas condições for verdadeira, retorna null.
// Caso contrário, retorna a mensagem.
if (msg.payload_status === 'HOME' || msg.payload_status === 'NOT_HOME') {
    return null;  // Retorna null se qualquer uma das condições for verdadeira.
} else {
    return msg;  // Retorna a mensagem se ambas as condições forem falsas.
}

//

//

// Verifica se a porcentagem está entre 50% e 100%
if (msg.payload >= 50 && msg.payload <= 80) {
    // Se estiver dentro do intervalo, passa o valor como msg.payload
    return msg;
} else {
    // Se estiver fora do intervalo, configura msg.reset para true
    msg.reset = true;
    delete msg.payload;  // Remove o msg.payload para não causar confusão
    return msg;
}

// Verifica se a porcentagem está entre 50% e 100%
if (msg.payload <= 50) {
    // Se estiver dentro do intervalo, passa o valor como msg.payload
    return msg;
} else {
    // Se estiver fora do intervalo, configura msg.reset para true
    msg.reset = true;
    delete msg.payload;  // Remove o msg.payload para não causar confusão
    return msg;
}

//

//

  {% set peak_hour = states('sensor.forecast_solar_peak_hour') %}
  {% set current_time = states('sensor.time') %}
  {{ peak_hour == current_time }}

//

//

// Verifica se o payload é igual à string "HOME" ou ao número 10
if (msg.payload === "HOME" || msg.payload === 10) {
    return msg; // Retorna o resultado na única saída
} else {
    return null; // Retorna null se não for igual a "HOME" ou 10
}

// Verifica se o payload é igual à string "HOME" E ao número 10 ao mesmo tempo
if (msg.payload === "HOME" && msg.payload === 10) {
    return msg; // Retorna o resultado na única saída
} else {
    return null; // Retorna null se não for igual a "HOME" E 10
}

// Verifica se o payload é igual ao número 10
if (msg.payload === 10) {
    return [msg, null]; // Retorna na saída 1 se for igual a 10
} else {
    return [null, msg]; // Retorna na saída 2 se for diferente de 10
}

// Verifica se o payload é igual à string "HOME"
if (msg.payload === "HOME") {
    return [msg, null]; // Retorna na saída 1 se for igual a "HOME"
} else {
    return [null, msg]; // Retorna na saída 2 se for diferente de "HOME"
}

// Verifica se o payload é igual a um valor específico
if (msg.payload === "valor_especifico") {
    return [msg, null, null]; // Retorna na saída 1
} 
// Verifica se o payload é diferente de um valor específico
else if (msg.payload !== "valor_especifico") {
    return [null, msg, null]; // Retorna na saída 2
} 
// Verifica se o payload é maior ou igual a 10
else if (msg.payload >= 10) {
    return [null, null, msg]; // Retorna na saída 3
} 
// Caso nenhuma condição seja atendida, retorna nulo
else {
    return [null, null, null];
}

//

  1.  != (igualdade frouxa): Faz a comparação apenas dos valores, sem considerar os tipos de dados. Isso significa que ele tenta converter os dois lados para o mesmo tipo antes de compará-los. Por exemplo:
  • 5 != "5" retorna false, porque os valores são iguais, mesmo que sejam de tipos diferentes (um número e uma string).
  2.  !== (igualdade estrita): Compara tanto o valor quanto o tipo de dados. Ou seja, não faz conversão automática de tipo. Se os tipos forem diferentes, a comparação retorna true. Exemplo:
  • 5 !== "5" retorna true, porque o número 5 e a string "5" têm tipos diferentes, mesmo que os valores sejam iguais.

Quando usar:

  • Use != se você quiser que o JavaScript faça conversões de tipo para você (igualdade frouxa).
  • Use !== quando quiser que a comparação seja mais rigorosa, levando em conta o tipo de dado (igualdade estrita).

Em muitos casos, o uso de !== é recomendado para evitar comportamentos inesperados por causa de conversões automáticas de tipos.

Topic: cmnd/ir_bridge_mbr/irsend
 
Payload: {"Protocol":"NEC","Bits":32,"Data":"0x4EBB926D","DataLSB":"0x72DD49B6","Repeat":0}

input_number:
  leitura_energia:
    name: Leitura Energia
    initial: 0
    min: 0
    max: 100000
    step: 1
    unit_of_measurement: 'kWh'
    icon: 'mdi:gauge'

Crie um sensor que fará o cálculo da diferença entre a leitura atual e a leitura anterior. Isso será o seu consumo diário de kWh
template:
  - sensor:
      - name: "Consumo Diário de Energia"
        unit_of_measurement: "kWh"
        state: >
          {% set leitura_atual = states('input_number.leitura_energia') | float %}
          {% set leitura_anterior = states('sensor.leitura_energia_anterior') | float %}
          {{ leitura_atual - leitura_anterior }}
        availability: "{{ states('input_number.leitura_energia') not in ['unknown', 'unavailable'] and states('sensor.leitura_energia_anterior') not in ['unknown', 'unavailable'] }}"

Automação para salvar o valor atual do input_number.leitura_energia como a leitura anterior no final de cada dia
automation:
  - alias: "Salvar Leitura Anterior de Energia"
    trigger:
      - platform: time
        at: '23:59:59'  # No final do dia
    action:
      - service: input_number.set_value
        data:
          entity_id: input_number.leitura_energia_anterior
          value: "{{ states('input_number.leitura_energia') }}"

Incluir o sensor sensor.consumo_diario_de_energia no dashboard para visualizar o consumo de kWh manualmente calculado
type: entities
entities:
  - entity: input_number.leitura_energia
    name: "Leitura Atual (kWh)"
  - entity: sensor.consumo_diario_de_energia
    name: "Consumo Diário (kWh)"